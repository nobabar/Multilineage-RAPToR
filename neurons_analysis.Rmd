---
title: "Multi traj RAPToR"
author: "Baptiste Rousseau"
date: "2023-11-01"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: hide
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE)
```

```{r library, message=FALSE}
library(Biobase)
library(dplyr)
library(GEOquery)
library(ica)
library(limma)
library(RAPToR)
library(Seurat)
library(slingshot)
library(scales)
library(tradeSeq)
library(viridis)
library(wormRef)

source("multige_im.R")
source("utils.R")
```

```{r}
dspacker <- readRDS("./data/eset_packer.rds")
dspacker$lineage2 <- substr(dspacker$lineage, 1, 2) # make 2 char lineage

# select neurons lineages ASE, ASJ and AUA
csel <- grepl(pattern = "ASE|ASJ|AUA", dspacker$cell.subtype)
table(dspacker$cell.subtype[csel], dspacker$embryo.time.bin[csel])

pX <- exprs(dspacker) # extract counts
table(rowSums(pX) < 10) # filter low-expressed genes (also to lighten the data)

# select annotated cells from one batch
sel_cells <- dspacker$batch == "Waterston_400_minutes" & dspacker$lineage != "unannotated" & grepl(pattern = "ASE|ASJ|AUA", dspacker$cell.subtype)

pX <- as.matrix(pX[rowSums(pX) > 10, sel_cells])

p_fpx <- pData(dspacker)[sel_cells,]
```

# Preprocessing data

```{r}
# normalize & log
pX <- limma::normalizeBetweenArrays(pX, method = "quantile")
pX <- log1p(pX)

# compute correlation matrix
cc <- cor(pX, method="spearman")
diag(cc) <- NA # remove 1 diagonal
filt <- apply(cc, 1, quantile, probs=.99, na.rm=T)
thr <- mean(filt) - 2*sd(filt) # define threshold based on 99th percentile distribution
boxplot(cc, border = 1+(filt<=thr), col = 0+7*(filt<=thr), names=NA,
        xlab = "Samples", ylab = "Spearman corr. with other samples", )

pX <- pX[,filt>thr]
p_fpx <- p_fpx[filt>thr,]
```

We remove `r sum(filt<thr)` samples and keep `r sum(filt>thr)`.

```{r}
seu <- CreateSeuratObject(counts = pX)
seu <- NormalizeData(seu)
seu <- FindVariableFeatures(seu, nfeatures = 2000)
seu <- ScaleData(seu)

seu <- AddMetaData(seu, p_fpx["cell.subtype"], 
                   col.name = "cell.subtype")
```

Distribution of different celltypes

```{r, fig.height=8}
VlnPlot(seu, c("nCount_RNA", "nFeature_RNA"), pt.size = 0.1, ncol = 1, group.by = "cell.subtype")
```

# Dimension reduction

UMAP can better preserve pairwise distance of cells than tSNE and can better separate cell populations than the first 2 PCs of PCA, so we will work with UMAP rather than tSNE or PCA.

```{r, message=FALSE}
seu <- RunPCA(seu)
seu <- RunUMAP(seu, n.neighbors = 10, dims = 1:50, spread = 2, min.dist = 0.3, seed.use = 654)
DimPlot(seu, reduction = "umap",
        group.by = "cell.subtype", pt.size = 0.5, label = TRUE, repel = TRUE)
```

# Search clusters

clusters correspond to cell types

```{r, message=FALSE}
seu <- FindNeighbors(seu, verbose = FALSE, dims = 1:50)
seu <- FindClusters(seu, algorithm = 1, random.seed = 654, resolution = 1)

# Plot the clusters
DimPlot(seu, reduction = "umap", group.by = "seurat_clusters", pt.size = 0.5, label = TRUE)
```

# Slingshot

```{r}
# slingshot ----
set.seed(654)
sds <- slingshot(Embeddings(seu, "umap"), clusterLabels = seu$seurat_clusters, stretch = 0)
sds <- as.SlingshotDataSet(sds)

# create the color palette
cell_pal <- function(cell_vars, pal_fun,...) {
  if (is.numeric(cell_vars)) {
    pal <- pal_fun(100, ...)
    return(pal[cut(cell_vars, breaks = 100)])
  } else {
    categories <- sort(unique(cell_vars))
    pal <- setNames(pal_fun(length(categories), ...), categories)
    return(pal[cell_vars])
  }
}

cell_colors <- cell_pal(seu$cell.subtype, brewer_pal("qual", "Set2"))
cell_colors_clust <- cell_pal(seu$seurat_clusters, hue_pal())


curves <- as.SlingshotDataSet(getCurves(sds, approx_points = 300, thresh = 0.01,
                                        stretch = 0.8, allow.breaks = FALSE,
                                        shrink = 0.99))
```

Lineages inferred by slingshot :

```{r}
plot(slingReducedDim(sds), col = cell_colors, pch = 16)
lines(curves, lwd = 3, col = "black")
```

```{r}
pt <- slingPseudotime(sds)
nms <- colnames(pt)
pal <- viridis(100, end = 0.95)
par(mfrow = c(1, 2))
for (i in nms) {
  colors <- pal[cut(pt[,i], breaks = 100)]
  plot(slingReducedDim(sds), col = colors, pch = 16, main = i)
  lines(curves, lwd = 2, col = 'black')
}
```

# Differential expression

```{r}
counts <- as.matrix(seu@assays$RNA@counts[seu@assays$RNA@var.features, ])
dim(counts)

sce <- fitGAM(counts = as.matrix(counts), sds = curves)
```

We can look at which genes are differentially expressed along lineages.

```{r}
pseudotime_association <- associationTest(sce)
pseudotime_association$fdr <- p.adjust(pseudotime_association$pvalue, method = "fdr")
pseudotime_association <- pseudotime_association[order(pseudotime_association$pvalue), ]
pseudotime_association$feature_id <- rownames(pseudotime_association)

plot_differential_expression <- function(feature_id, counts, clustering) {
  feature_id <- pseudotime_association %>% filter(pvalue < 0.05) %>% top_n(1, -waldStat) %>% pull(feature_id)
  cowplot::plot_grid(plotGeneCount(curves, counts, gene = feature_id[1], clusters = clustering, models = sce) + ggplot2::theme(legend.position = "none"), 
                     plotSmoothers(sce, as.matrix(counts), gene = feature_id[1]))
}

feature_id <- pseudotime_association %>% filter(pvalue < 0.05) %>% top_n(1, -waldStat) %>% pull(feature_id)

plot_differential_expression(feature_id, counts, seu$seurat_clusters)
```

# Dimension reduction

```{r}
p_fpx$embryo.time <- p_fpx$embryo.time - min(p_fpx$embryo.time) + 1

cell_subtypes <- seu$cell.subtype

ctypes <- unique(cell_subtypes)

# define lineage cell sets
lins <- list(
  ASJ = cell_subtypes %in% ctypes[c(1, 4, 5)],
  AUA = cell_subtypes %in% ctypes[c(1, 5, 6)],
  ASE = cell_subtypes %in% ctypes[c(1, 2, 3)]
)
```

```{r message=FALSE, results=FALSE}
prepare_and_interpolate <- function(X, p, lins, dim_red="ica", nc=8){
  mt <- multige_im(X = X, p = p, lineages = lins,
                   dim_red = dim_red, nc = nc,
                   formulas = c("X~s(embryo.time, bs='cr', k=6)",
                                "X~s(embryo.time, bs='cr', k=6)",
                                "X~s(embryo.time, bs='cs', k=6)",
                                "X~s(embryo.time, bs='cr', k=5)",
                                "X~s(embryo.time, bs='cr', k=5)",
                                "X~s(embryo.time, bs='cr', k=5)",
                                "X~s(embryo.time, bs='cr', k=4)",
                                "X~s(embryo.time, bs='cr', k=4)"))
  
  # predict new data (in comp. space)
  ndat <- data.frame(embryo.time=seq(min(p$embryo.time),
                                     max(p$embryo.time), l=100))
  nX <- predict_mgeim(mt, ndat, as.c = T)
  interpGE <- predict_mgeim(mt, ndat)
  
  return(list(mt=mt, ndat=ndat, nX=nX, interpGE=interpGE))
}
```

# RAPToR

```{r}
# build train and test
p <- 0.8
rr <- split(1:length(cell_subtypes), cell_subtypes)
idx <- sort(as.numeric(unlist(sapply(rr, function(x) sample(x, length(x) * p)))))

pX_train <- pX[idx, ]
pX_test <- pX[-idx, ]

p_fpx_train <- p_fpx[idx, ]
p_fpx_test <- p_fpx[-idx, ]
```

First let's build sets with 80/20 while keeping original proportions. In other words, stratified splitting of the dataset.

Original proportions :
```{r}
table(p_fpx$cell.subtype) / nrow(p_fpx)
```

Train proportions :
```{r}
table(p_fpx_train$cell.subtype) / nrow(p_fpx_train)
```

Test proportions :
```{r}
table(p_fpx_test$cell.subtype) / nrow(p_fpx_test)
```

We can see that the proportions are similar enough.

# Interpolation

```{r, message=FALSE, results=FALSE}
multige <- prepare_and_interpolate(pX, p_fpx, lins)

plot_lineages(multige$mt, multige$ndat, multige$nX,
              p_fpx$embryo.time, p_fpx$cell.subtype, 1:8)
```

# Staging

```{r, message=FALSE, results=FALSE}
res <- lapply(1:4, function(i){
  idx <- stratified_split(cell_subtypes)
  
  pX_train <- pX[, idx]
  pX_test <- pX[, -idx]
  
  p_fpx_train <- p_fpx[idx, ]
  p_fpx_test <- p_fpx[-idx, ]
  
  lins_train <- lapply(lins,'[', idx)
  lins_test <- lapply(lins,'[', -idx)
  
  multige <- prepare_and_interpolate(pX_train, p_fpx_train, lins_train)
  
  ae_s_train <- lapply(multige$interpGE, function(rdat){
    RAPToR::ae(samp = pX_train, refdata = rdat, ref.time_series = multige$ndat$embryo.time,
        bootstrap.n = 30)
  })
  
  ae_s_test <- lapply(multige$interpGE, function(rdat){
    RAPToR::ae(samp = pX_test, refdata = rdat, ref.time_series = multige$ndat$embryo.time,
        bootstrap.n = 30)
  })
  
  return(list(multige=multige,
              train=list(idx=idx,
                         ae_s=ae_s_train),
              test=list(idx=seq_along(cell_subtypes)[!seq_along(cell_subtypes) %in% idx],
                        ae_s=ae_s_test)))
})
```

Predictions for train :

```{r, message=FALSE, results=FALSE}
plot_staged(res[[1]]$train$ae_s, p_fpx[res[[1]]$train$idx, ]$embryo.time, lapply(lins,'[', res[[1]]$train$idx))
```

Predictions for test :

```{r, message=FALSE, results=FALSE}
plot_staged(res[[1]]$test$ae_s, p_fpx[res[[1]]$test$idx, ]$embryo.time, lapply(lins,'[', res[[1]]$test$idx))
```

Results from 4 differents runs :

train pearson r :
```{r}
reduce_cor(res, lins, p_fpx, "train", "pearson")
```

train spearman rho :
```{r}
reduce_cor(res, lins, p_fpx, "train", "spearman")
```

test pearson r :
```{r}
reduce_cor(res, lins, p_fpx, "test", "pearson")
```

test spearman rho :
```{r}
reduce_cor(res, lins, p_fpx, "test", "spearman")
```

# Exploring lineage-inference from staging

```{r, message=FALSE, results=FALSE}
plot_lineages_inference(res[[1]]$train$ae_s,
                        p_fpx[res[[1]]$train$idx, ]$cell.subtype,
                        ctypes[c(1,5,4,6,3,2)],
                        lapply(lins,'[', res[[1]]$train$idx))
```


```{r, message=FALSE, results=FALSE}
plot_lineages_inference(res[[1]]$test$ae_s,
                        p_fpx[res[[1]]$test$idx, ]$cell.subtype,
                        ctypes[c(1,5,4,6,3,2)],
                        lapply(lins,'[', res[[1]]$test$idx))
```

Results from 4 different runs :

train :
```{r}
reduce_summary(res, lins, ctypes[c(1,5,4,6,3,2)], "train")
```

test :
```{r}
reduce_summary(res, lins, ctypes[c(1,5,4,6,3,2)], "test")
```

# Normalization

Predictions for train :

```{r, message=FALSE, results=FALSE}
plot_lineage_inference_norm(res[[1]]$train$ae_s,
                            p_fpx[res[[1]]$train$idx, ]$cell.subtype,
                            ctypes[c(1,5,4,6,3,2)],
                            p_fpx[res[[1]]$train$idx, ]$embryo.time,
                            lapply(lins,'[', res[[1]]$train$idx))
```

Predictions for test :

```{r, message=FALSE, results=FALSE}
plot_lineage_inference_norm(res[[1]]$test$ae_s,
                            p_fpx[res[[1]]$test$idx, ]$cell.subtype,
                            ctypes[c(1,5,4,6,3,2)],
                            p_fpx[res[[1]]$test$idx, ]$embryo.time,
                            lapply(lins,'[', res[[1]]$test$idx))
```

Results from 4 different runs :

train :
```{r}
reduce_norm_summary(res, lins, ctypes[c(1,5,4,6,3,2)], "train")
```

test :
```{r}
reduce_norm_summary(res, lins, ctypes[c(1,5,4,6,3,2)], "test")
```
